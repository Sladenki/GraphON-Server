# Оптимизация кэширования Redis

## Проблема
Исходная реализация кэширования создавала отдельный кэш для каждого пользователя, что приводило к:
1. Неэффективному использованию памяти Redis
2. Дублированию данных графов для каждого пользователя
3. Проблемам с актуальностью данных при изменении подписок

## Решение

### Новая архитектура кэширования

#### 1. Разделение кэша на два уровня:
- **Базовые данные графов** - кэшируются без информации о подписках
- **Подписки пользователей** - кэшируются отдельно с коротким TTL

#### 2. Ключи кэша:
- `graph:getParentGraphs:{"skip":0}` - базовые данные графов
- `graph:getAllChildrenGraphs:{"parentGraphId":"...","skip":0}` - базовые данные дочерних графов
- `userSubs:userId` - подписки конкретного пользователя

#### 3. TTL (Time To Live):
- Базовые данные графов: 1 день (86400 секунд)
- Подписки пользователей: 5 минут (300 секунд)

### Преимущества новой системы:

1. **Эффективность памяти**: Один кэш графов для всех пользователей
2. **Актуальность данных**: Короткий TTL для подписок + инвалидация при изменениях
3. **Производительность**: Быстрое получение подписок из кэша
4. **Масштабируемость**: Система работает одинаково хорошо для любого количества пользователей

### Инвалидация кэша:

При изменении подписок (подписка/отписка) автоматически инвалидируется кэш подписок пользователя:
- `toggleSub()` - инвалидирует кэш подписок
- `toggleSubBulk()` - инвалидирует кэш подписок

### Использование:

```typescript
// Получение графов с информацией о подписках
const graphs = await graphService.getParentGraphs(skip, userId);

// Если userId не передан - возвращаются графы без isSubscribed
// Если userId передан - добавляется поле isSubscribed для каждого графа
```

### Мониторинг:

Для мониторинга эффективности кэширования можно использовать:
- Redis команды: `INFO memory`, `INFO stats`
- Ключи кэша: `KEYS graph:*`, `KEYS userSubs:*` 